package.jsonに置いて
  "dev": "next dev -p 80",
  で80番ポートを解放している理由は、nodeサービスを競合してしまい、エラーが発生するため。
  3000以外のn番ポートが開いていればOK

docsfolder
  ドキュメントを配置する。
  仕様書やOpenApi定義もここに配置する。

publicfolder
  静的ファイルを配置する。
  Nextjsで定義されたディレクトリ。

api
  WebApi等の外部APIのクライアントを配置する。
  自動生成されたApiのラッパーを作る時もここに配置する。

compornent
  UIコンポーネントを配置する。
  Atomic Designの分類に基づいてコンポーネント振り分ける。

component/atoms
  部品となる汎用UIコンポーネントを配置する。
  単体で存在できるUIならここに配置する。

components/molecules
  複数のUIコンポーネントを組み合わせたUIコンポーネントを配置する。
  特定のコンテキストに依存しないようして再利用を考慮する。
  UI制御のロジックが必要であればhooksを提供する。

src/components/templates/
  ページ全体のスケルトンになるUIコンポーネントを配置する。
  ページのアクセス制御やレイアウト等を含んだコンポーネント。


React ->2013年に公開されたJSのライブラリ
facebookが開発し、facebook,slack,udemy,Qiita,NetFlix,Airbandbなどに使われている

仮想DOMという方式でDOMの変更箇所のみをレンダリングする機構を持っているため、高速
JQueryがもたらしたDOMの変更箇所がどこか？と開発者が気にしなければならなかった問題の解消


●Webpack
モジュールバンドら
ソースコードを束ねてブラウザで実行できる静的なJSファイルを出力
複数npmを使用する場合必須
AファイルをImportでBファイル内でを使用する場合
Webpackl.config.js内のentryにBファイルを記入し、outputにC.jsファイルと記入すると、CファイルにAとBファイルがまとまる
そのまとまったJSを他のjs内で使うことができる
→複数のJSファイルをいちいちあるページに指定するのではなく、Webpackに記載してまとめることでoutputに書かれたファイルのみを記載して全てのjsファイルを使用できる

ReactのアプリケーションでもWebpackを使用している。

ブラウザの検証等でページを見たさいにsrc＝に書かれているファイル名がWebpack内のoutputに指定されたファイル（バンドルされたファイル）

●Component
ReactにはComponentというものがある
①関数の定義によって作成するfunctionalコンポーネント
②クラス定義によって作成するclassコンポーネント

●props
propsとはコンポーネントの属性のこと
props.nameやprops.ageのようなあるデータの属性（名前、年齢）に対して、参照できるもののこと
propsには数値や文字列、配列、オブジェクト、関数などなんでも使用することができる
基本的には{}で囲ってpropsを渡していく
function（User）の引数にpropsを入れ、その内部で{props.name(属性)というふうに記入}
そのfunctionを使用する際に、User name={""}というふうに記入する
1propsに複数個の属性を入れることができる
User = (props) => {
{props.name} {props.age}のように
}

reactで仮想DOMの変更時は変更点だけを実際のDOMに反映するが、それぞれのDOMにキーを与え、
必要最低限なDOMの範囲をreactが管理している（つまり、DOMを指し示すキーを与える必要がある。）
配列の場合は、引数に（配列,index） key={index}というふうにキーを与えるのがベストプラクティス

deafultPropsについて
propsを受け取るコンポーネントにdefaultPropsを設定する

User.defaultProps = {
  age: 1
}
のように内部のpropsをあらかじめ設定しておく。他function内部でageを指定されなかった場合は自動で１がはいる

上記のように親のコンポーネントからこのコンポーネントにデータを渡したいとなった時に、propsを使ってデータを渡す。子コンポーネントはそれを参照して画面を描画する

コンポーネントではコンポーネントの内部で状態を持てる
その状態のことをstate
stateはコンポーネントの内部でのみ使用される
propsは変更不可能（イミュータブル）
stateは変更可能（ミュータブル）

コンポーネントの初期化時（呼び出されてインスタンスが作成される）にはconstructor（）メソッドがコールされる
super()はconstructor（）内部でのみ使用可能
最初の初期化時の状態に対して、オブジェクトが設定される。

状態（state）を変更する場合にはthis.setStateを使うという決まりがある
this.stateで直接stateを触ることはできない
理由：
状態を直接いじっても、画面のstateは変わらない、そこでやりたいことは、状態を変えることとその状態に関連するDOMを更新したい
状態を変えた時によしなに画面のDOMをレンダリングして欲しい。
→その仕組みがsetState

●Reduxとは
Fluxアーキテクチャの１つ
モチベーション
コンポーネントの改造が大きくなってきたときに、簡単に、状態を共有する手段を提供する

コンベンション
Reduxアプリケーションをコーディングする上での多くの習慣にしたがってコーディングする必要がある

action
→アプリケーションの中で何が起きたかということを示すデータのこと.
jsのオブジェクトのこと。その中でタイプというキーとタイプに対応する値を持つ
そのタイプの値はユニークでなければならない

複数の場所で活用されるデータについては１箇所で管理してそれを再利用する

●Reducer(stateの変更の責任を担う)
Reduxの基本機能の１つ
アクションが発生した時にそのアクションに組み込まれているTypeに応じて、
状態(state)をどう変化させるのかということを定義するもの。
アプリケーションの事実上の状態を持つのがreducer

●connect
React-reduxが提供する関数
→stateやアクション、コンポーネントとの関連づけを行い、ビューのイベントで状態を遷移させて、
遷移後の状態を画面に際描画する

連携する外部サービス
登録、更新、参照、削除を行う
３つの登場人物
①クライアント（ブラウザ）
②Staticファイルサーバ（Firebaseで運用しているファイルサーバ）
③APIサーバ（Herokuで運用しているrailsアプリケーション）

流れ
①Reactアプリケーションの取得　クライアントがstaticファイルサーバに対してReactアプリケーションを要求するメッセージを投げる
②メッセージを受け取ったstaticファイルサーバはそのリクエストの応答として、Html、Css、JSなどのファイルを返す
③Reactアプリケーションのファイルセットを受け取ったクライアント端末は、次にAPIサーバに対して、さまざまな種類のリクエストを投げる
④全レコードを取得するリクエストの送信
⑤APIサーバでは全レコードをDBから読み取るJsonの配列を応答メッセージとしてクライアントに返す
④あるレコードの読み取りをしたい場合にはIDがn版のレコードをくれとAPIサーバに要求
⑤APIサーバはそのレコードをDBから探すデータが見つかったら該当レコードをJsonのオブジェクトとしてクライアントに返す
④データの作成、APIサーバにデータを作成してくださいと要求
⑤APiサーバではそのレコードを作成する。そして、DBに保存。保存に成功したら、該当レコードの内容をJsonオブジェクトでクライアントに返す
④クライアント端末がある特定レコードの更新をしたいとAPIサーバに要求
⑤APIサーバは該当のレコードが見つかった場合には、その要求通りにデータを更新して、更新後のデータをJsonのオブジェクトとしてクライアントに返す
④クライアント端末は、特定のレコードを削除する要求をAPIサーバに送信
⑤APIサーバはその要求を受け取った場合、該当レコードを探し、そのレコードが見つかった場合にはそのデータをDBから削除する。
削除が完了したら、その削除されたデータのオブジェクトをクライアント端末に返す

React　CRUDアプリケーションの仕様
イベント管理アプリ
→イベントを作成、参照、更新、削除できる
Create,Read,Update,Deleteの頭文字をとってCRUD（クラッド）アプリケーションという
イベントに関するデータは外部サーバより取得したもの

右下のボタンでは作成画面の表示が行える
Title、内容でサブミット

ReactアプリケーションとAPIサーバ間のネットワーク上のデータの流れについて
トークン（クエリストリング）認証後に付与される認証トークン、１２３はサンプル
今回のAPIサーバでは管理される全てのイベントはトークン単位で空間が切られている
→ユーザごとに管理対象のイベントが分離
→自分専用のイベントを作成して管理する場合、識別子をトークン１２３以外の文字列にする

OPTIONSリクエストメソッド
→次のリクエストでPUTリクエストを送信するために、事前にPUTリクエストを送信できるものなのかどうか、
事前にAPIに確認するもの（そのリクエストが本当にある？と確認するもの、PUT以外でも使われる）

PUTリクエストメソッド
→特定のIDのレコードを更新する要求（Request Payloadの内容を反映）
200　OK（正常に更新できた）

POSTリクエストメソッド
→データを作成する要求（Request Payloadの内容を反映）
201 created（正常にデータ作成できた）

DELETEリクエストメソッド
→特定のIDのレコードを削除する要求（レスポンスで消されたレコードが帰ってくる）
200　OK（正常に更新できた）

GETリクエストメソッド
→データの一覧、詳細どちらも要求する

Access-Control-Allow-Methods
→受け付けることのできるメソッドの一覧

curl（カール）コマンドで、外部のAPIサーバに対して、指定の形式でリクエストを送ることで、実際にデータをCRUDできる

●axiosとは
外部のAPIサーバに対して、Httpのリクエストを送信するための便利な「ライブラリ」

●redux-thunkとは
Reduxのアクションクリエーターに非同期処理を実装するためのパッケージ
